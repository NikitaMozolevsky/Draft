package by.mozolevskij.pharmacy.example.learning.spring_theory;

public class SpringSecurity {
    /** АУНТЕФИКАЦИЯ
     * Доказание сервису что я - зарегестрированный пользователь
     * посредством ввода логина и пароля
     *
     * АВТОРИЗАЦИЯ
     * Говорит что я как пользователь могу делать после аунтефикация
     * пользователь авторизуется на разные роли
     *
     * SpringSecurity работает посредством фильтров, фильтр перехватывает все HTTP запросы,
     * пример: фильтр PUT, PATCH, DELETE запросов
     *
     * Для реализации аунтефикации SpringSecurity создается класс, реализующий AuthenticationProvider
     * с одним методом authenticate() в методе описывается логика аунтефикации пользователя,
     * принимает и возвращает объект Auntefication.class, несет в себе логин и пароль пользователя.
     * Внутри Auntefications есть Credentials - user login and password
     *
     * Способы аунтефикации: в БД, обращение к серверу, который проверяет.
     *
     * На выходе в Auntefication.class может находиться еще и Principal, который
     * получается на выходе после успешной аунтефикации (в него обычно кладется
     * сам пользователь)
     * Далее после каждого запроса пользователя в запросе будет лежать Principal
     * который будет давать данные о пользователе, не нужно повторно проходить аунтуфикацию
     * после каждого запроса, сервер уже меня запомнил, мои данные
     *
     * Но ведь протокол HTTP stateless, не имеет состояния, каждый запрос не зависим друг от
     * друга? Посл аунтефикации обхект Principal помещаетсяя в сессию пользователя,
     * при каждом запросе объект Principal подгружается из сессии, за это отвечает
     * отдельный фильтр SpringSecurity
     *
     * */
}
